import java.util.*;

class Config {
    int simDays = 7;
    int initPumps = 2;
    int maxPumps = 10;
    double flow = 20.0;
    double qThresh = 12.0;
    double expDelay = 2.0 * 24 * 60;
    double initFuel = 10000.0;
    double maxFuel = 15000.0;
    double delivInt = 24.0 * 60;
    double delivVol = 10000.0;
    double delivDur = 30.0;
    int seed = 42;
}

class Car {
    int id;
    double tank;
    double level;
    double need;
    double arr;
    double start;
    double end;

    Car(int id, double tank, double level, double need, double arr) {
        this.id = id;
        this.tank = tank;
        this.level = level;
        this.need = need;
        this.arr = arr;
    }
}

class Pump {
    int id;
    double flow;
    boolean busy;
    Car car;
    double totalBusy;

    Pump(int id, double flow) {
        this.id = id;
        this.flow = flow;
    }
}

class Event implements Comparable<Event> {
    double time;
    String type;
    Pump pump;
    Car car;

    Event(double time, String type) {
        this(time, type, null, null);
    }

    Event(double time, String type, Pump pump) {
        this(time, type, pump, null);
    }

    Event(double time, String type, Pump pump, Car car) {
        this.time = time;
        this.type = type;
        this.pump = pump;
        this.car = car;
    }

    public int compareTo(Event o) {
        return Double.compare(this.time, o.time);
    }
}

class Sim {
    Config cfg;
    Random rand;
    double time;
    List<Pump> pumps;
    Queue<Car> queue;
    double fuel;
    double lastDeliv;
    boolean pumpOpenScheduled;
    double expansionTriggerTime;
    PriorityQueue<Event> events;

    int carCnt;
    int served;
    int refused;
    List<Double> waitTimes;
    List<Double> serviceTimes;
    double maxWait;
    int maxQLen;
    int pumpOpens;
    int delivCnt;
    List<double[]> fuelHist;
    double minFuel;
    Map<Integer, Double> pumpUtil;

    Sim(Config cfg) {
        this.cfg = cfg;
        this.rand = new Random(cfg.seed);
        this.time = 0.0;
        this.pumps = new ArrayList<>();
        for (int i = 0; i < cfg.initPumps; i++) {
            pumps.add(new Pump(i, cfg.flow));
        }
        this.queue = new LinkedList<>();
        this.fuel = cfg.initFuel;
        this.lastDeliv = 0.0;
        this.pumpOpenScheduled = false;
        this.expansionTriggerTime = -1e9;
        this.events = new PriorityQueue<>();
        events.add(new Event(0.0, "arrival"));
        events.add(new Event(cfg.delivInt, "delivery"));

        this.carCnt = 0;
        this.served = 0;
        this.refused = 0;
        this.waitTimes = new ArrayList<>();
        this.serviceTimes = new ArrayList<>();
        this.maxWait = 0.0;
        this.maxQLen = 0;
        this.pumpOpens = 0;
        this.delivCnt = 0;
        this.fuelHist = new ArrayList<>();
        fuelHist.add(new double[]{0.0, cfg.initFuel});
        this.minFuel = cfg.initFuel;
        this.pumpUtil = new HashMap<>();
        for (Pump p : pumps) {
            pumpUtil.put(p.id, 0.0);
        }
    }

    double lam(double t) {
        double h = (t % (24 * 60)) / 60;
        if (h < 6) return 0.03;
        if (h < 10) return 0.25;
        if (h < 16) return 0.12;
        if (h < 20) return 0.30;
        return 0.08;
    }

    double nextArr() {
        double u = rand.nextDouble();
        while (u == 0) u = rand.nextDouble();
        return -Math.log(u) / lam(time);
    }

    Car genCar() {
        carCnt++;
        double[] tanks = {40, 50, 60, 70, 80};
        double tank = tanks[rand.nextInt(tanks.length)];
        double level = tank * (0.1 + 0.8 * rand.nextDouble());
        double need = 5 + rand.nextDouble() * (tank - level - 5);
        if (need > tank - level) need = tank - level;
        return new Car(carCnt, tank, level, need, time);
    }

    Pump freePump() {
        for (Pump p : pumps) {
            if (!p.busy) return p;
        }
        return null;
    }

    void startServe(Pump p, Car c) {
        c.start = time;
        double wait = c.start - c.arr;
        waitTimes.add(wait);
        if (wait > maxWait) maxWait = wait;
        if (wait > cfg.qThresh && time - expansionTriggerTime > cfg.expDelay) {
            schedulePumpOpen();
            expansionTriggerTime = time;
        }

        double serveT = c.need / p.flow;
        serviceTimes.add(serveT);
        c.end = time + serveT;
        p.busy = true;
        p.car = c;
        events.add(new Event(c.end, "service_end", p, c));
    }

    void schedulePumpOpen() {
        if (!pumpOpenScheduled && pumps.size() < cfg.maxPumps) {
            events.add(new Event(time + cfg.expDelay, "pump_open"));
            pumpOpenScheduled = true;
        }
    }

    void run() {
        double endTime = cfg.simDays * 24 * 60;
        while (!events.isEmpty() && time <= endTime) {
            Event e = events.poll();
            time = e.time;
            if (time > endTime) break;

            switch (e.type) {
                case "arrival": {
                    Car c = genCar();
                    if (fuel < c.need) {
                        refused++;
                    } else {
                        Pump p = freePump();
                        if (p != null) {
                            startServe(p, c);
                        } else {
                            queue.add(c);
                            if (queue.size() > maxQLen) maxQLen = queue.size();
                        }
                    }
                    events.add(new Event(time + nextArr(), "arrival"));
                    break;
                }
                case "service_end": {
                    Pump p = e.pump;
                    Car c = p.car;
                    fuel -= c.need;
                    if (fuel < 0) fuel = 0;
                    fuelHist.add(new double[]{time, fuel});
                    if (fuel < minFuel) minFuel = fuel;
                    served++;
                    p.busy = false;
                    p.car = null;
                    if (!queue.isEmpty()) {
                        Car nxt = queue.poll();
                        if (fuel >= nxt.need) {
                            startServe(p, nxt);
                        } else {
                            refused++;
                        }
                    }
                    break;
                }
                case "delivery": {
                    fuel = Math.min(fuel + cfg.delivVol, cfg.maxFuel);
                    fuelHist.add(new double[]{time, fuel});
                    delivCnt++;
                    events.add(new Event(time + cfg.delivInt, "delivery"));
                    break;
                }
                case "pump_open": {
                    if (pumps.size() < cfg.maxPumps) {
                        int newId = pumps.size();
                        pumps.add(new Pump(newId, cfg.flow));
                        pumpUtil.put(newId, 0.0);
                        pumpOpens++;
                        pumpOpenScheduled = false;
                        if (!queue.isEmpty()) {
                            int toServe = Math.min(queue.size(), pumps.size());
                            for (int i = 0; i < toServe; i++) {
                                if (!queue.isEmpty()) {
                                    Pump free = freePump();
                                    if (free != null) {
                                        Car nxt = queue.poll();
                                        if (fuel >= nxt.need) {
                                            startServe(free, nxt);
                                        } else {
                                            refused++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    break;
                }
            }
        }

        for (Pump p : pumps) {
            pumpUtil.put(p.id, p.totalBusy / (cfg.simDays * 24 * 60) * 100);
        }
    }

    void stats() {
        double avgWait = waitTimes.stream().mapToDouble(d -> d).average().orElse(0);
        double avgServ = serviceTimes.stream().mapToDouble(d -> d).average().orElse(0);
        double avgFuel = fuelHist.stream().mapToDouble(arr -> arr[1]).average().orElse(0);

        System.out.println("=== Результаты симуляции АЗС (" + cfg.simDays + " дней) ===");
        System.out.println("Прибыло автомобилей: " + carCnt);
        System.out.println("Обслужено: " + served);
        System.out.println("Отказов (нет топлива): " + refused);
        System.out.printf("Ср. ожидание в очереди: %.2f мин\n", avgWait);
        System.out.printf("Макс. ожидание: %.2f мин\n", maxWait);
        System.out.printf("Ср. время обслуживания: %.2f мин\n", avgServ);
        System.out.println("Макс. длина очереди: " + maxQLen);
        System.out.println("Колонок в начале: " + cfg.initPumps);
        System.out.println("Колонок в конце: " + pumps.size());
        System.out.println("Открыто доп. колонок: " + pumpOpens);
        System.out.println("Доставок топлива: " + delivCnt);
        System.out.printf("Ср. остаток топлива: %.2f л\n", avgFuel);
        System.out.printf("Мин. остаток топлива: %.2f л\n", minFuel);
        System.out.print("Загрузка колонок:");
        for (Map.Entry<Integer, Double> e : pumpUtil.entrySet()) {
            System.out.printf(" #%d: %.0f%%", e.getKey(), e.getValue());
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Config cfg = new Config();
        Sim sim = new Sim(cfg);
        sim.run();
        sim.stats();
    }
}
```
